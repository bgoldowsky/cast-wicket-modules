/*
 * Copyright 2011 CAST, Inc.
 *
 * This file is part of the CAST Wicket Modules:
 * see <http://code.google.com/p/cast-wicket-modules>.
 *
 * The CAST Wicket Modules are free software: you can redistribute and/or
 * modify them under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * The CAST Wicket Modules are distributed in the hope that they will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this software.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.cast.cwm.xml.service;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.xml.XMLConstants;
import javax.xml.namespace.NamespaceContext;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import lombok.Getter;
import lombok.Setter;

import org.apache.wicket.Resource;
import org.apache.wicket.util.file.File;
import org.apache.wicket.util.time.Time;
import org.cast.cwm.xml.DomCache;
import org.cast.cwm.xml.FileResource;
import org.cast.cwm.xml.ICacheableModel;
import org.cast.cwm.xml.IDocumentObserver;
import org.cast.cwm.xml.IXmlPointer;
import org.cast.cwm.xml.TransformResult;
import org.cast.cwm.xml.XmlDocument;
import org.cast.cwm.xml.XmlSection;
import org.cast.cwm.xml.parser.XmlParser;
import org.cast.cwm.xml.transform.EnsureUniqueWicketIds;
import org.cast.cwm.xml.transform.IDOMTransformer;
import org.cast.cwm.xml.transform.TransformChain;
import org.cast.cwm.xml.transform.TransformParameters;
import org.cast.cwm.xml.transform.XslTransformer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.bootstrap.DOMImplementationRegistry;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSSerializer;

/**
 * Service class to load XML documents, set up and request XSL transforms, manage caching and updating from the filesystem, etc.
 *  
 * @author borisgoldowsky
 *
 */
public class XmlService {
	
	private static XmlService INSTANCE = new XmlService();
	
	/**
	 * Keeps track of all XmlDocuments in the system, hashed by their name.
	 * This allows XmlDocument objects to be accessed without serializing and keeping copies of them.
	 */
	@Getter
	protected Map<String,XmlDocument> documents = new HashMap<String,XmlDocument>();
	
	/**
	 * Tracks all known transformers, by name.
	 */
	@Getter
	protected Map<String,IDOMTransformer> transformers = new HashMap<String,IDOMTransformer>();
	
	/**
	 * Class of XmlSection object that will be created by all methods in this module.
	 */
	@Getter @Setter
	protected Class<? extends XmlSection> xmlSectionClass = XmlSection.class;
	
	/**
	 * Wait at least this many seconds between checks of files for updates.
	 */
	@Getter @Setter
	protected int updateCheckInterval = 10;
	
	/**
	 * Cache for DOMs generated by transforming XML.
	 */
	protected DomCache domCache;
	
	@Getter
	protected NamespaceContext namespaceContext = new CwmNamespaceContext();

	private static final Logger log = LoggerFactory.getLogger(XmlService.class);

	/**
	 * Get the registered instance of this service class.
	 * Applications may install their own extended version.
	 * @return
	 */
	public static XmlService get () {
		return INSTANCE;
	}
	
	// Do not call from elsewhere; this is a singleton class.
	protected XmlService () {
	}
	
	/**
	 * Fetch an XmlDocument by name from the ones registered with this object.
	 * @param name
	 * @return the XmlDocument, or null.
	 */
	public XmlDocument getDocument (String name) {
		return documents.get(name);
	}
	
	/**
	 * Fetch a transformer by name from the ones registered with this object.
	 * @param name
	 * @return the transformer, or null.
	 */
	public IDOMTransformer getTransformer (String name) {
		return transformers.get(name);
	}
	
	/**
	 * Return new XmlSection, or a subclass as set in this object's xmlSectionClass.
	 * @return the newly instantiated object
	 */
	public XmlSection newXmlSection() {
		try {
			return xmlSectionClass.newInstance();
		} catch (Exception e) {
			throw new RuntimeException("Failed to create XmlSection", e);
		}
	}
	
	/**
	 * Load an XML document from a File and register it by name with this object.  
	 * @see {@link #loadXmlDocument(String, Resource)}
	 * @param name name for this XML document (must be globally unique)
	 * @param file the file that contains the XML text
	 * @param parser the XML parser to be used
	 * @param observers (optional) list of initial document observers 
	 * @return the loaded and registered XmlDocument
	 */
	public XmlDocument loadXmlDocument (String name, File file, XmlParser parser, List<IDocumentObserver> observers) {
		return loadXmlDocument (name, new FileResource(file), parser, observers);
	}
	
	/** 
	 * Read an XML document from the given Resource.
	 * It will be remembered by this service class and can thereafter be referred to by the given name.
	 *  
	 * @param name name for this XML document (must be globally unique)
	 * @param xmlResource Resource from which to read the XML content
	 * @param parser the XML parser to be used
	 * @param observers (optional) list of initial document observers
	 * @return the XmlDocument
	 */
	public XmlDocument loadXmlDocument (String name, Resource xmlResource, XmlParser parser, List<IDocumentObserver> observers) {
		XmlDocument doc = new XmlDocument(name, xmlResource, parser, observers);
		doc.setSortOrder(documents.size());
		registerXmlDocument(name, doc);
		return doc;
	}
	
	/** 
	 * Register the provided XmlDocument object with this service class.
	 * @param name
	 * @param document
	 */
	public void registerXmlDocument (String name, XmlDocument document) {
		if (documents.containsKey(name))
			throw new IllegalArgumentException("XML Document with duplicate name: " + name);
		documents.put(name, document);		
	}
	
	/**
	 * Create and load a transformer based on the given XSL File.
	 * If second argument is true, then a secondary transformation will be chained on, which makes
	 * sure that all wicket:id attributes (likely created by the XSL) are made unique. 
	 * @param name
	 * @param xslFile
	 * @param forceUniqueWicketIds
	 * @return the transformer
	 */
	public IDOMTransformer loadXSLTransformer (String name, File xslFile, boolean forceUniqueWicketIds, File... dependentFiles) {
		Resource[] resources = new Resource[dependentFiles.length];
		for (int i=0; i<dependentFiles.length; i++)
			resources[i] = new FileResource(dependentFiles[i]);
		return loadXSLTransformer(name, new FileResource(xslFile), forceUniqueWicketIds, resources);
	}
	
	/**
	 * Create and load a transformer based on the given Resource, which should point to an XSL document.
	 * If second argument is true, then a secondary transformation will be chained on, which makes
	 * sure that all wicket:ids created by the XSL are made unique. 
	 * @param name
	 * @param xslResource
	 * @param forceUniqueWicketIds
	 * @return the transformer
	 */
	public IDOMTransformer loadXSLTransformer (String name, Resource xslResource, boolean forceUniqueWicketIds, Resource... dependentResources) {
		XslTransformer xsl = new XslTransformer(xslResource);
		for (Resource r : dependentResources)
			xsl.addDependentResources(r);
		IDOMTransformer transformer;
		if (forceUniqueWicketIds)
			transformer = new TransformChain(xsl, new EnsureUniqueWicketIds());
		else
			transformer = xsl;
		registerTransformer(name, transformer);
		return transformer;
	}
	
	/**
	 * Register the provided DOM Transformer under the name provided.
	 */
	public void registerTransformer (String name, IDOMTransformer transformer) {
		if (transformers.containsKey(name))
			throw new IllegalArgumentException("XML Document with duplicate name: " + name);
		transformers.put(name, transformer);
	}
	
	/**
	 * Get transformed version of given XML, either from cache or by executing transform.
	 * @param sec
	 * @param transformName
	 * @return the transformed DOM Element.
	 */
	public TransformResult getTransformed (ICacheableModel<? extends IXmlPointer> mXmlPtr, String transformName) {
		return getTransformed(mXmlPtr, transformName, null);
	}

	/**
	 * Get transformed version of given XML, either from cache or by executing transform.  You
	 * can optionally specify parameters that are considered part of the cache key.
	 * 
	 * @param sec
	 * @param transformName
	 * @return the transformed DOM Element.
	 */
	public TransformResult getTransformed (ICacheableModel<? extends IXmlPointer> mXmlPtr, String transformName, TransformParameters params) {
		IDOMTransformer transformer = XmlService.get().getTransformer(transformName);
		// First, check the cache.
		net.sf.ehcache.Element cacheElement = getDomCache().get(mXmlPtr, transformName, params);
		if (cacheElement != null) {
			// Compare last-modified times of cache, XML, and transformer.
			Time cacheTime = Time.valueOf(cacheElement.getLastUpdateTime() != 0 ? cacheElement.getLastUpdateTime() : cacheElement.getCreationTime());
			// This call to getLastModified() will also update the XML if necessary
			Time xmlTime = mXmlPtr.getLastModified();
			Time transTime = transformer.getLastModified(params);
			if ((xmlTime==null || xmlTime.before(cacheTime)) && (transTime==null || transTime.before(cacheTime))) {
				// Cache is still valid
				return (TransformResult) cacheElement.getObjectValue();
			}
		}
		// Still here?  Cache was empty or outdated.  Do a new transform.
		IDOMTransformer trans = getTransformer(transformName);
		if (trans == null)
			throw new IllegalArgumentException("Transformer not registered: " + transformName);
		// Do the transform and cache the result.
		// TODO: What if mXmlPtr is now pointing to null due to a change in the XML document?
		TransformResult tr = new TransformResult(trans.applyTransform((Element) mXmlPtr.getObject().getElement().cloneNode(true), params));
		domCache.put(mXmlPtr, transformName, tr, params);
		return (tr);
	}

	/**
	 * @param res
	 * @return
	 * 
	 * This will return a string of the elements children.  Can be used to get the html content from a child/children.
	 */
	public String serialize (Element res) {
		DOMImplementationRegistry registry;
		try {
			registry = DOMImplementationRegistry.newInstance();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
		DOMImplementationLS impl = 
			(DOMImplementationLS)registry.getDOMImplementation("LS");
		if (impl == null) {
			throw new RuntimeException ("Could not find appropriate DOM implementation");
		} else {
			LSSerializer writer = impl.createLSSerializer();
			writer.getDomConfig().setParameter("xml-declaration", false);
			// May want to set a filter to deal with Components embedded in XML
			// writer.setFilter(filter);
			return writer.writeToString(res);
		}
	}

	protected DomCache getDomCache() {
		if (domCache == null)
			domCache = new DomCache();
		return domCache;
	}
	
	public void addNamespaceContext(String prefix, String uri) {
		((CwmNamespaceContext) getNamespaceContext()).putNamespacePair(prefix, uri);
	}
	
	/**
	 * Finds wicket nodes for a given element. This method either returns all of the 
	 * wicket nodes (up and down the DOM) or the first layer of wicket nodes immediately
	 * below the provided element.
	 * 
	 * @param elt the element to search
	 * @param all true, if searching the entire tree.  false, if just searching for the first wicket children.
	 * @return
	 */
	public NodeList getWicketNodes(Element elt, boolean all) {
		XPathFactory factory=XPathFactory.newInstance();
		XPath xPath = factory.newXPath();
		xPath.setNamespaceContext(getNamespaceContext());
		XPathExpression xp;
		NodeList nodes = null;
	
		try {
			if (all)
				xp = xPath.compile("//*[@wicket:id]");
			else
				xp = xPath.compile(".//*[@wicket:id][ancestor::*[@wicket:id][1] = current() or not(ancestor::*[@wicket:id])]");
			nodes = (NodeList) xp.evaluate(elt, XPathConstants.NODESET);
		} catch (XPathExpressionException e) {
			e.printStackTrace();
		}
	
		return nodes;
	}

	protected static class CwmNamespaceContext implements NamespaceContext, Serializable {

		private static final long serialVersionUID = 1L;

		private Map<String, String> prefix2uri = new HashMap<String, String>();
		private Map<String, String> uri2prefix = new HashMap<String, String>();
		
		protected CwmNamespaceContext() {
			putNamespacePair("dtb", "http://www.daisy.org/z3986/2005/dtbook/");
			putNamespacePair("wicket", "http://wicket.apache.org");
			putNamespacePair(XMLConstants.DEFAULT_NS_PREFIX, "http://www.w3.org/1999/xhtml");
		}
		
		protected void putNamespacePair (String prefix, String uri) {
			prefix2uri.put(prefix, uri);
			uri2prefix.put(uri, prefix);
		}
		
		public String getNamespaceURI(String prefix) {
			if (prefix == null)
				throw new IllegalArgumentException("Prefix cannot be null");			
			return prefix2uri.get(prefix);
		}


		public String getPrefix(String uri) {
			if (uri == null)
				throw new IllegalArgumentException("URI cannot be null");
			return uri2prefix.get(uri);
		}

		public Iterator<Void> getPrefixes(String arg0) {
			log.error("Called unimplemented function getPrefixes");
			return null;
		}
	}

	public static void setInstance(XmlService xmlService) {
		INSTANCE = xmlService;
	}
}
